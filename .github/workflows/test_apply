on:
  schedule:
    - cron: '0 2 * * 2' #Runs at "2AM UTC every Tuesday" which is equivalent to "10:00 PM ET every Monday", Monday at 10pm ET was chosen to minimize the potential impact to iPipeline employees & contractors using SSO
  pull_request:
    types: [ closed, unlabeled, opened,reopened,synchronize ]
    branches:
     - master
    paths:
     - 'applied/accounts/global/us-east-1/awssso/**'
     - 'infrastructure/region/awssso/**'
     - '!**.md'    # do not run the job when only changing markdown files
     - '.github/**'  #this is will ensure workflows run when there is changes made to actions workflow

env:
  TERRAFORM_VERSION: 1.3.7  # the version of terraform to install in this runner
  TERRAGRUNT_VERSION: 0.42.7 # the version of terragrunt to install in this runner
  ORCHESTRATION_ROLE_ARN: 'arn:aws:iam::119662755212:role/awssso_orchestration_role' #iam-global
  #The orchestration role defined here will assume a state management role defined in the backend.tf and a worker role defined in the provider.tf. 
  #Both of those terraform files are generated by terragrunt so the roles are defined in the terragrunt.hcl file.
  TERRAFORM_WORKING_DIR: './applied/accounts/global/us-east-1/awssso/'  #scoped to only AWS SSO Terraform code
  TERRAFORM_LOCK_HCL_PATH: './applied/accounts/global/us-east-1/awssso/.terraform.lock.hcl' #path to the .terraform.lock.hcl file is required for GitHub Actions to add and commit

permissions:
  id-token: write       # write permissions are needed to generate the OIDC token for AWS
  contents: write       # write permissions are needed in order to commit changes back to the branches
  issues: write         # write permissions are needed in order to create comments
  pull-requests: write  # write permissions are needed in order to create comments

concurrency: production  # This will ensure that only a single PR workflow will run at a time to avoid different workflow running terraform plan & apply trying to acquire state lock at the same time causing one to fail

jobs:
  docs_awssso:
        - name: Terragrunt Apply
        id: apply
        #this is doing a plan by design for now.
        #after merging to master and testing the plan works, we'll create another PR to change this to apply
        run: terragrunt run-all apply -no-color --terragrunt-non-interactive
        continue-on-error: true
        
        if: steps.apply.outcome == 'success' || steps.apply.outcome == 'failure'
        run: |
          if [[ "${{steps.apply.outcome}}" == "success" ]]; then
             apply="${{steps.apply.outputs.stdout}}"
             # Remove refresh section
             filtered_output=$(echo "${apply}" | grep -E '^(Terraform used the selected providers to generate the following execution plan\.|No changes\. Your infrastructure matches the configuration\.|Terraform has compared your real infrastructure against your configuration and found no differences, so no changes are needed\.|Apply complete! Resources:).*')
             # truncate filtered output to 65536 character
             truncated_output=$(echo "${filtered_output:0:65536}")
             # Set the resulting string as an environment variable
             echo "APPLY_OUTPUT<<EOF" >> $GITHUB_ENV
             echo "***Apply Output***:<details><summary>Show Apply Success</summary>" >> $GITHUB_ENV
             echo -e "${truncated_output}" >> $GITHUB_ENV
             echo "EOF" >> $GITHUB_ENV
          else
             apply="${{ steps.apply.outputs.stderr }}"
             if echo "${apply}" | grep -q '^Error: '; then
               error_section=$(echo "${apply}" | sed -n '/^Error:/,$p' | head -n 100)
               echo "APPLY_OUTPUT<<EOF" >> $GITHUB_ENV
               echo "***Apply Output***:<details><summary>Show Apply Fail</summary>" >> $GITHUB_ENV
               echo "${error_section}" >> $GITHUB_ENV
               echo "EOF" >> $GITHUB_ENV
             fi
          fi
